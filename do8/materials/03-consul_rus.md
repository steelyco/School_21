# Consul

Изначально приложения имели монолитную структуру, то есть состояли из одного большого сервиса. Такой подход стал терять популярность для многих веб-решений в силу нарастания актуальности следующих проблем:

1. Такие сервисы сложно масштабировать. Даже если требуется масштабировать всего один модуль, на практике это означает перемасштабирование всего приложения.
2. Малая гибкость. Стек технологий для каждого отдельного модуля сильно завязан и на технологиях, используемых в других модулях монолита.
3. Сложность разработки. Обычно чем больше становится монолит, тем сложнее в него вносить изменения, так как зачастую между модулями проекта нет четких протоколов взаимодействия, что часто приводит к потребности в изменении большого числа модулей для внесения дополнительного функционала лишь в один.

В ответ этим проблемам возникла новая идея — изменить архитектуру монолитную на микросервисную. Теперь каждая отдельная сущность управляется отдельным сервисом и взаимодействует с остальными модулями по четко установленному протоколу. К тому же микросервисы теперь могут свободно располагаться в кластере, используя совершенно независимые стеки. Но, как это обычно и бывает, это привело к другим не менее серьезным проблемам:

1. Обнаружение сервисов. Сервисы должны четко знать, где конкретно расположены другие сервисы, а это означает сложную конфигурацию модулей, сильно зависящую от топологии сети.
2. Безопасность. Микросервисы передают данные друг другу по открытой сети, а значит, эти данные могут быть перехвачены. Появляется новая уязвимость.

**Consul** — это инструмент для осуществления паттерна Service Discovery, призванного в первую очередь избавить приложения с микросервисной архитектурой от ручного конфигурирования каналов связи. Теперь, вместо прямого общения между сервисами, они, перед тем как быть развернутыми в качестве части микросервисного приложения, регистрируются в отдельном *registry*. Каждый же отдельный микросервис обращается лишь к прокси-серверу *envoy*, расположенному локально для этого микросервиса (то есть «ходит» на свой localhost). Прокси-сервер резолвит запросы микросервиса автоматически, исходя из того, какие зарегистрированные в системе IP-адреса с необходимыми данному микросервису сервисами возвращает *registry*.

Таким образом, все сервисы объединяются в одну логическую единицу — Service Mesh, обладающий своим датацентром, одним или несколькими consul-серверами и множеством зарегистрированных в данном Service Mesh сервисах. К тому же Service Mesh обеспечивает авторизацию и шифрование соединений между сервисами с использованием протокола защиты транспортного уровня (TLS), а «голый» трафик сервисов никогда не покидает конкретный узел.

<img src="misc/images/consul_diagram.png"  width="400">

Consul имеет клиент-серверную архитектуру. На некоторой машине в сети устанавливается сервер consul, который и будет осуществлять Service Discovery в комбинации с легковесными клиентами-агентами, расположенными на зарегистрированных машинах с сервисами и осуществляющими проксирование.

Работа Consul определяется конфигурационным файлом, указываемым при запуске consul. Конфигурационный файл перед запуском можно провалидировать командой `consul validate <имя конфигурационного файла>`.

Основные поля конфигурационного файла consul:
- `server` — флаг, отвечающий за тип агента (клиент/сервер — true/false).
- `advertise_addr` — IP-адрес, используемый для объявления другим узлам в кластере.
- `bind` — IP-адрес/интерфейс, который агент использует на локальной для него машине.
- `ports` — порты для работы агентов consul (например, grpc).
